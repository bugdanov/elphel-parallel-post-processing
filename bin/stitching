#!/bin/bash
#
# elphel-parallel-processing - Elphel camera array images post processing using GNU parallel
#
# Copyright (c) 2013-2014 FOXEL SA - http://foxel.ch
# Please read <http://foxel.ch/license> for more information.
#
# Author(s):
#
#      Luc Deschenaux <l.deschenaux@foxel.ch>
#      Kevin Velickovic <k.velickovic@foxel.ch>
#
# This file is part of the FOXEL project <http://foxel.ch>.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
#
# Additional Terms:
#
#      You are required to preserve legal notices and author attributions in
#      that material or in the Appropriate Legal Notices displayed by works
#      containing it.
#
#      You are required to attribute the work as explained in the "Usage and
#      Attribution" section of <http://foxel.ch/license>.

[ -n "$DEBUG" ] && set -x

set -e

usage() {

  if [ "$1" == "-h" ] ; then
    echo "$(basename $0) [-h|--help] [OPTION...] <sourceDir>  <destDir> [ -o <script> ]"
    exit 1
  fi

  cat >&2 << EOF

SYNOPSIS:

    $(basename $0) [OPTION...] <sourceDir>  <destDir> [ -o <script> ]

DESCRIPTION:

    Generate a script to process unprocessed files from <sourceDir> and place
    the resulting files in <destDir>, using GNU parallel.

    With recent GNU parallel versions from http://gnu.org/s/parallel, the
    sshloginfile can be modified at runtime (to change the local or remote
    number of jobs to run in parallel)

    Arguments for the output scripts are passed to GNU parallel. They can also
    be specified in the PARALLEL environment variable (or with the -p option
    when queue mode is enabled with --run).

QUEUE MODE:

    If no output script name, or option --run is set, the processing is started
    immediately (before the full list of timestamps is built), using the output
    script as a queue, until "EOQ" is queued

RESUME PROCESSING:

    To resume processing, run the output script again.

OPTIONS SUMMARY:
    -h,--help                      display this
    -s,--shuffle                   process progressively instead of sequentially
    -o,--output <script>           set output script name
    -r,--run                       start processing immediately in queue mode
    -p,--parallel <options>        when -r is specified, set gnu parallel options
    -l,--logdir <path>             set log directory
    -f,--filelist <file_list>      files to process. <sourceDir> will be ignored

    -m,--method enblend|multiblend set stitching method
    -b,--black <black point>       set black point
    -w,--white <white point>       set white point
    -q,--quality <quality>         set jpeg quality
    -e,--eqrformat <format>        set EQR format (RGB24 INT16 INT32 FLOAT32)

EXAMPLES:

    # generate script first, then run it
    $ stitching -s /data/footage/1412953653-00-0E-64-08-1C-D2/tiles/DECONV-RGB24_EQR/ /data/footage/1412953653-00-0E-64-08-1C-D2/panoramas/enblend -o /data/footage/1412953653-00-0E-64-08-1C-D2/stitching.sh
    $ /data/footage/1412953653-00-0E-64-08-1C-D2/stitching.sh -j30

    # run in queue mode, start processing while script is generated
    $ stitching  -r -p "-j30" -s /data/footage/1412953653-00-0E-64-08-1C-D2/tiles/DECONV-RGB24_EQR/ /data/footage/1412953653-00-0E-64-08-1C-D2/panoramas/enblend -o /data/footage/1412953653-00-0E-64-08-1C-D2/stitching.sh

    # resume execution after interruption
    /data/footage/1412953653-00-0E-64-08-1C-D2/stitching.sh -j30

EOF
  exit 1
}

init() {

  checkdependencies

  [ $# -lt 1 ] && usage -h

  # parse command line options
  if ! options=$(getopt -o hsrflb:w:g:q:o:p:m:e: -l help,shuffle,black:,white:,gamma:,quality:,run,filelist:,logdir:,output:,parallel:method:eqrformat: -- "$@")
  then
      # something went wrong, getopt will put out an error message for us
      exit 1
  fi

  eval set -- "$options"

  while [ $# -gt 0 ] ; do
      case $1 in
      -h|--help) usage $1 ;;
      -s|--shuffle) SHUFFLE="yes" ;;
      -b|--black) BLACKPOINT=$2 ; shift ;;
      -w|--white) WHITEPOINT=$2 ; shift ;;
      -g|--gamma) GAMMA=$2 ; shift ;;
      -q|--quality) QUALITY=$2 ; shift ;;
      -r|--run) RUN=yes ;;
      -f|--filelist) FILELIST=$2 ; shift ;;
      -l|--logdir) LOGDIR=$2 ; shift ;;
      -p|--paralell) export PARALLEL="$2" ; shift ;;
      -m|--method)  METHOD=$2 ; shift ;;
      -o|--output) OUTPUT=$2 ; shift ;;
      -e|--eqrformat) EQRFORMAT=$2 ; shift ;;
      (--) shift; break ;;
      (-*) echo "$(basename $0): error - unrecognized option $1" 1>&2; exit 1 ;;
      (*) break ;;
      esac
      shift
  done

  [ $# -lt 2 ] && usage -h

  SRCDIR=$(realpath "$1")
  DSTDIR=$(realpath "$2")

#  assertenv SRCDIR DSTDIR

  cd $HOME

  # default values
  [ -z "$QUALITY" ] && QUALITY=98
  [ -z "$EQRFORMAT" ] && EQRFORMAT=INT16
  [ -z "$BLACKPOINT" ] && BLACKPOINT=0
  if [ -z "$WHITEPOINT" ] ; then
    echo "$(basename $0): warning - you should set --white point manually" ;
    case $EQRFORMAT in
      RGB24) WHITEPOINT=100 ;;
      INT16) WHITEPOINT=25 ;;
      *) WHITEPOINT=100 ;;
    esac
  fi
  [ -z "$GAMMA" ] && GAMMA=1
  [ -z "$METHOD" ] && METHOD=enblend

  # current timestamp
  NOW=$(date +%s) # _%N

  # default output script name
  if [ -z "$OUTPUT" ] ; then
    OUTPUT="stitching-$NOW"
    RUN=true
  fi

  # set and create directories
  [ -z "$LOGDIR" ] && LOGDIR=log/stitching
  mkdir -p $LOGDIR
  mkdir -p $DSTDIR

  # set remote script path
  if [ -z "$REMOTESCRIPT" ] ; then
    REMOTESCRIPT=$(which stitch.sh)
    REMOTESCRIPT=${REMOTESCRIPT#$HOME/}
  fi

  [ -z "$REMOTESCRIPT" ] && REMOTESCRIPT=bin/stitch.sh

  # set remote logger path
  if [ -z "$REMOTELOGGER" ] ; then
    REMOTELOGGER=$(which paralog.sh)
    REMOTELOGGER=${REMOTELOGGER#$HOME/}
  fi

  [ -z "$REMOTELOGGER" ] && REMOTELOGGER=bin/paralog.sh

  # set parallelbang path
  if [ -z "$PBANG" ] ; then
    PBANG=$(which parallelbang)
    PBANG=${PBANG#$HOME/}
  fi

  [ -z "$PBANG" ] && PBANG=bin/parallelbang

  return 0

}

main() {

  init "$@"

  echo "#!$PBANG --gnu -I _TIMESTAMP_ --ungroup --joblog $LOGDIR/$(basename $OUTPUT).log --bf $REMOTESCRIPT --bf $REMOTELOGGER $REMOTESCRIPT $SRCDIR $DSTDIR _TIMESTAMP_ -q $QUALITY -b ${BLACKPOINT} -w ${WHITEPOINT} -m ${METHOD} -e ${EQRFORMAT} \\\\\\\\| $REMOTELOGGER $OUTPUT" | tee "$OUTPUT"
  chmod +x "$OUTPUT"

  if [ "$RUN" == "true" -o "$RUN" == "yes" ] ; then
    # run in queue mode
    echo "#### running $OUTPUT" 1>&2
    listUnprocessedTimestamps | tee -a "$OUTPUT" | parallel --gnu -I _TIMESTAMP_ --ungroup --joblog $LOGDIR/$(basename $OUTPUT).log --bf $REMOTESCRIPT --bf $REMOTELOGGER $REMOTESCRIPT $SRCDIR $DSTDIR _TIMESTAMP_ -q $QUALITY -b ${BLACKPOINT} -w ${WHITEPOINT} -m ${METHOD} \| $REMOTELOGGER $OUTPUT

  else
    # or generate output script
    listUnprocessedTimestamps | tee -a "$OUTPUT"

  fi

  echo "#### saved as $OUTPUT" 1>&2

}

listUnprocessedTimestamps() {
  listTimestamps | while read TIMESTAMP ; do
    [ -s "$DSTDIR/result_${TIMESTAMP}-$BLACKPOINT-$WHITEPOINT-$GAMMA.jpeg" ] || echo $TIMESTAMP
  done
}

assertcommands() {
  while [ $# -ne 0 ] ; do
    local CMD=$1
    shift
    [ -z "$(which $CMD)" ] && echo command $CMD not found >&2 && exit 1
  done || true
}

checkdependencies() {
  assertcommands realpath parallel ssh
}

# return the list of timestamps to process
listTimestamps() {

  # build tiff list if not passed as parameter
  if [ -z "$FILELIST" ] ; then
    FILELIST="/tmp/filelist_stitch_$NOW.tmp"
    find "$SRCDIR" -maxdepth 2 -name \*.tiff > $FILELIST
  else
    echo "Using files listed in $FILELIST" 1>&2
  fi

  # output shuffled or sorted timestamp list
  if [ -n "$SHUFFLE" ] ; then
    shuffile
  else
    cat "$FILELIST" | tiffListToTimestampList
  fi
}

# read tiff list from stdin, return sorted timestamp list
tiffListToTimestampList() {
  while read TIFF ; do
    TIFF=$(basename $TIFF)
    echo ${TIFF:0:17}
  done | sort -u
}

# return shuffled (progressive) timestamp list,
# reducing the step by half recursively
shuffile() {
  argv=($(cat "$FILELIST" | tiffListToTimestampList))
  argc=${#argv[*]}
  last=$((argc - 1))
  [ $last -eq 0 ] && last=1
  step=$(expr $argc / 2)
  [ $step -eq 0 ] && step=1
  while true ; do
    for (( i=0; i<$argc ; i+=step )) ; do
      if [ -n "${argv[$i]}" ] ; then
        echo ${argv[$i]}
        argv[$i]=
      fi
    done
    if [ -n "${argv[$last]}" ] ; then
      echo ${argv[$last]}
      argv[$last]=
    fi
    [ $step -eq 1 ] && break
    ((step/=2))
  done
}

# print usage and exit if given environment variables are not set
assertenv() {
  for name in $@ ; do
    if [ -z "$(printenv $name)" ] ; then
      echo error: $name is not set ! >&2
      usage
    fi
  done
}

main "$@"
